---
title: "How to use mergebamsR"
output: html_document
date: "2024-05-16"
always_allow_html: true
editor_options: 
  chunk_output_type: console
---

## Installing Rust

First you need to have an updated Rust installation. Go to this [site](https://www.rust-lang.org/tools/install) to learn how to install Rust.


## Installing mergebamsR

You will need to have the devtools package installed...

```{r, eval=F}
devtools::install_github("furlan-lab/mergebamsR")
```


## Running mergebamsR

Loading libraries
```{r, dpi=300, fig.height=4, fig.width = 6}
rm(list=ls())
suppressPackageStartupMessages({
  library(mergebamsR)
})

outpath<-"/tmp"
root<-file.path(.libPaths()[1], "mergebamsR/extdata/test")
```

## Simple merging of two bams located in test folder

These two bam files are located in the test directory of this repository.  To create a merge of the two bam files in the test/out folder, run the following.

```{r}
mergebams(bams = c("inst/extdata/test/bam1.bam","inst/extdata/test/bam2.bam"), out_path = outpath)
```


## Prepending cell barcodes (CB)

When merging bams from single cell data, it may be advantageous to include additional information in the cell barcode tag that reflects the merge.  In this case we are merging the two bam files but prepending the cell barcodes with the prefixes "test_1_" for the first file and "test_2_" for the second file.  The prefixes parameter must contain a character vector of prefixes of equal length to the character vector of the bams argument.

```{r}
mergebams(bams = c(file.path(root, "bam1.bam"), file.path(root, "bam2.bam")), out_path = outpath, prefixes = c("test1_","test2_"))
```

## Filtering

Finally, it may also be useful to filter bam files to include only specific reads.  mergebamsR provides this feature.  By supplying a list of character vectors containing read names to be kept, one can filter the output bam to only have reads of interest.  Again, the list length needs to be the same length as the bams character vector input.
```{r}
mergebams(bams = c(file.path(root, "bam1.bam"), file.path(root, "bam2.bam")), 
          out_path = outpath, 
          prefixes = c("test1_","test2_"), 
          names = list(c("VH00738:4:AAAW2TWHV:1:2512:20125:30230", "VH00738:4:AAAW2TWHV:1:1612:47827:5146"), 
                       c("VH00738:4:AAAW2TWHV:2:2114:49683:55957", "VH00738:4:AAAW2TWHV:2:1203:65210:13741")))
```

For situations in which only certain bam files are to be filtered, include a NULL in the list for those files that are not meant to be filtered.  In the below, we filter two reads from bam1.bam and retain all reads from bam2.bam.

```{r}
mergebams(bams = c(file.path(root, "bam1.bam"), file.path(root, "bam2.bam")), 
          out_path = outpath, 
          prefixes = c("test1_","test2_"), 
          names = list(c("VH00738:4:AAAW2TWHV:1:2512:20125:30230", "VH00738:4:AAAW2TWHV:1:1612:47827:5146"), 
                       NULL))
```

## Subset individual BAM files

Although other tools already exist for subsetting bam files using shell scripting, it may be helpful to subset BAM files by BAM tag using an R interface such that single-cell toolkits such as Seurat, Monocle, or SCE can be run adjacent.  mergebamsR provides this usability.  Currently only one bam file is supported as input.  The number of each elements of the following should all be the same:
1. the list "tags" which specifies desired TAGS to be captured in each output file
2. a vector of file output names
3. optional prefixes to be added to each TAG

Note that multithreading has been implemented to split work byt the number of outputbam files created.  Therefore, for example, you should use 2 cores if creating two bam files.


TAG is the name of the BAM Tag to subset by.  The default is "CB".

```{r}
subsetbam(inputbam = file.path(root, "bam1.bam"), outputbams = "/tmp/test.bam", tags = list(c("ATTGGACAGTCATGCT-1", "TTTACTGAGTCGATAA-1")), cores=1)
```

To peek at a few of the TAGs of interest

```{r}
cbs = peekbam(bam = file.path(root, "bam1.bam"), TAG="CB", n=100)
cbs
```

Now we can make two bams at a time
```{r}
subsetbam(inputbam = file.path(root, "bam1.bam"), outputbams = c("/tmp/test1.bam", "/tmp/test2.bam"), tags = list(cbs[1:50], cbs[51:100]), cores=2)

```

Note you may need to remove the files if they exst
```{r}
file.remove(list.files("/tmp", full.names = T))

```

## working on larger bam files

Note that this bam file is too big to be included in the test.  You will want to use your own
First, we determined that there are 31920074 reads total.
Second, we can plot the number of reads per barcode
Third, we can select only barcodes that have > 10000 reads and less than 60000 and put them into a "middle.bam" and all other reads in the "extremes.bam"

We can potentially speed things up by chunking the bam across cores and doing the work that way (the default is to write each output bam with each core).  An example is shown below.

```{r}
bigbam<-"/Users/sfurlan/Desktop/merged_bams/geno_recipient_HSC.bam"
bigbam<-"/Users/sfurlan/Desktop/merged_bams/geno_recipient.bam"
cbs<-peekbam(bigbam, n = 31920074)
cbs<-peekbam(bigbam, n = 1045596)
dat<-table(cbs)
library(ggplot2)
ggplot(data.frame(nreads=log10(as.numeric(dat))), aes(x=nreads))+geom_density()+theme_bw()
mid<-names(dat)[dat>10000 & dat < 60000]
ext<-names(dat)[!(dat>10000 & dat < 60000)]
any(mid %in% ext)
any(ext %in% mid)

library(microbenchmark)

twocores<-microbenchmark(subsetbam(inputbam = bigbam, outputbams = c("/Users/sfurlan/Desktop/middle.bam", "/Users/sfurlan/Desktop/extremes.bam"), tags = list(mid, ext), cores=2))


eightcores<-microbenchmark(subsetbam(inputbam = bigbam, outputbams = c("/Users/sfurlan/Desktop/middle.bam", "/Users/sfurlan/Desktop/extremes.bam"), tags = list(mid, ext), cores=8, split_bam = T))
```


## Appendix
```{r Appendix}
sessionInfo()
```
