extern crate bam;
extern crate csv;
extern crate flate2;
extern crate itertools;

use itertools::Itertools;
use differ::{Differ, Tag};
// use flate2::GzBuilder;
// use flate2::Compression;
use bam::RecordWriter;
use bam::record::tags::TagValue;
// use bam::header::Tag;
use std::str;
// use flate2::read;
// use std::{
//     // error::Error,
//     ffi::OsStr,
//     fs::File,
//     io::{self, BufReader, BufRead, Write},
//     path::Path,
// };


#[derive(Clone)]
struct Params<'a> {
    bams: Vec<&'a str>,
    out_path: &'a str,
    names: Vec<&'a str>,
    prefixes: Vec<&'a str>,
    threads: usize,
}


pub fn mergebams_rust<'a> (bams: Vec<&str>, out_path: &'a str, names: Vec<&str>, prefixes: Vec<&str>){
    let params = load_params(bams, names, prefixes, out_path);
    let _header_result = checkheaders(params.clone());
    if let Ok((header, params)) = checkheaders(params){
        let _params = addtags(params, header);
        // if params.prefixes.len() == 0{
        //     return;
        // } else {
        //     let _result = lines_from_file(params);
        //     return;
        // }
    }else{
        eprintln!("ERROR: BAM header sequences do not match - you will need to fix this before merging bams");
    }

}


fn load_params<'a>(bams: Vec<&'a str>, names: Vec<&'a str>, prefixes: Vec<&'a str>, out_path: &'a str) -> Params<'a> {
    let threads = 1;
    
    Params{
        bams: bams,
        out_path: out_path,
        names: names,
        prefixes: prefixes,
        threads: threads,
    }
}


// fn lines_from_file(params: Params) -> io::Result<()>{
//     let out_csv = params.out.to_string()+"/out_barcodes.tsv.gz";
//     let s1 = params.bcs.to_string();
//     let tsvvec = s1.split(",").collect::<Vec<&str>>();
//     let labvec1 = params.labels.to_string();
//     let labvec = labvec1.split(",").collect::<Vec<&str>>();
//     let f = File::create(out_csv)?;
//     let mut gz = GzBuilder::new()
//                     .filename("/out_barcodes.tsv.gz")
//                     .write(f, Compression::default());

//     for (pos, filename) in tsvvec.iter().enumerate() {
//         let path = Path::new(filename);
//         let file = match File::open(&path) {
//             Err(_why) => panic!("couldn't open {}", path.display()),
//             Ok(file) => file,
//         };
//         if path.extension() == Some(OsStr::new("gz")){
//             let buf = BufReader::new(read::GzDecoder::new(file));
//             for line in buf.lines(){
//                 writeln!(&mut gz, "{}", labvec[pos].to_string() + &line.unwrap())?;
//             }
//         }else{
//             let buf = BufReader::new(file);
//             for line in buf.lines(){
//                 writeln!(&mut gz, "{}", labvec[pos].to_string() + &line.unwrap())?;
//             }
//         }
//     }
//     return Ok(());
// }


fn checkheaders(params: Params) -> Result<(bam::Header, Params), &'static str>{
    let bam_it = params.bams.iter().combinations(2);
    let mut grand_count = 0;
    for bam_pairs in bam_it {
        let mut header_vec = Vec::new();
        for inbam in bam_pairs.iter() {
            let hreader = bam::BamReader::from_path(inbam, 0).unwrap();
            let header = hreader.header().clone();
            header_vec.push(header);
        }
        let mut count = 0;
        let a = header_vec[0].reference_names();
        let b = header_vec[1].reference_names();
        let differ = Differ::new(&a, &b);
        for span in differ.spans() {
            match span.tag {
                Tag::Equal => (),
                _ => count+=1,
            }
        }

        eprintln!("Found {} discrepencies between sequence names in the header of:\n\n{}\nand:\n\n{}\n", count, bam_pairs[0], bam_pairs[1]);
        grand_count+=count;
    }
    if grand_count == 0{
        let new_header = make_new_header(params.bams.clone());
        return Ok((new_header, params));
    } else {
        return Err("Discrepent headers")
    }
    
}

fn make_new_header(bam_vec: Vec<&str>) -> bam::Header {
    // assumes no discrepencies in the headers across bams in bam_vec
    let hreader = bam::BamReader::from_path(bam_vec[0], 0).unwrap();
    let mut out_header = hreader.header().clone();
    let mergebam_line = bam_vec.join(", ");
    let _msg = out_header.push_line(&("@CO\tmergebams has included the BAM records from the following files (using the header from the first): ".to_owned()+&mergebam_line));
    return out_header;
}

fn addtags(params: Params, header: bam::Header) -> Params{
    let out_path = params.out_path.to_string()+"/out_path.bam";
    let fail_bam = params.out_path.to_string()+"/fail_bam.bam";
    let out_path_msg = out_path.clone();
    // let inputs = params.inputs.to_string();
    let bam_vec = params.bams.clone();
    let bam_vec_msg = params.bams.join(" and ");
    // let labels = params.labels.to_string();
    // let lab_vec = labels.split(",").collect::<Vec<&str>>();
    let lab_vec = params.prefixes.clone();
    let (read_threads, write_threads) = if (*&params.threads as i8) > 2{
        (((*&params.threads/2) -1) as u16, ((*&params.threads/2) -1) as u16)
    } else {
        (0 as u16, 0 as u16)
    };
    let mut fail_count = 0;
    let mut pass_count = 0;
    let mut other_count = 0;
    // let hreader = bam::BamReader::from_path(bam_vec[0], read_threads).unwrap();
    let mut pass_writer = bam::BamWriter::build()
        .write_header(true)
        .additional_threads(write_threads)
        .from_path(out_path, header.clone()).unwrap();
    let mut fail_writer = bam::BamWriter::build()
        .write_header(true)
        .additional_threads(0)
        .from_path(fail_bam, header.clone()).unwrap();
    eprintln!("Headers ok\nWriting:\n\n{}\nfrom:\n\n{}\n", out_path_msg, bam_vec_msg);
    for (pos, inbam) in bam_vec.iter().enumerate() {
        let reader = bam::BamReader::from_path(inbam.to_string(), read_threads).unwrap();
        for record in reader {
            let mut newrecord = record.as_ref().unwrap().clone();
            match record.unwrap().tags().get(b"CB") {
                Some(TagValue::String(array_view, _)) => {
                    let labstr = lab_vec[pos];
                    let preftag = labstr.as_bytes().to_vec();
                    let oldtag = array_view.to_vec();
                    let new_cb = &[preftag, oldtag].concat();
                    newrecord.tags_mut().remove(b"CB");
                    newrecord.tags_mut().push_string(b"CB", &new_cb);
                    pass_writer.write(&newrecord).unwrap();
                    pass_count+=1;
                },
                Some(TagValue::Char(value)) => {
                    let labstr = lab_vec[pos];
                    let preftag = labstr.as_bytes().to_vec();
                    let oldtag = value.to_string().as_bytes().to_vec();
                    let new_cb = &[preftag, oldtag].concat();
                    newrecord.tags_mut().remove(b"CB");
                    newrecord.tags_mut().push_string(b"CB", &new_cb);
                    pass_writer.write(&newrecord).unwrap();
                    other_count+=1;
                },
                _ => {
                    // eprintln!("ERROR: 'CB' not found");
                    fail_writer.write(&newrecord).unwrap();
                    fail_count+=1;
                }
            }
        }
    }
    eprintln!("Processed all reads!!\nFound:\n{} - reads PASSING\n{} - reads PASSING but with issues\n{} - reads FAILING", pass_count, other_count, fail_count);
    return params;
}
    


